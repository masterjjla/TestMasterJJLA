"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RemoteBuilder = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let findBuildAgent = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
        const result = process.env.ELECTRON_BUILD_SERVICE_ENDPOINT;
        if (result != null) {
            (0, (_builderUtil || _load_builderUtil()).debug)(`Remote build endpoint set explicitly: ${result}`);
            return result.startsWith("http") ? result : `https://${result}`;
        }
        const agentInfo = JSON.parse((yield (_nodeHttpExecutor || _load_nodeHttpExecutor()).httpExecutor.request({
            hostname: "www.electron.build",
            // add random query param to prevent caching
            path: `/find-build-agent?c=${Date.now().toString(32)}`
        })));
        return agentInfo.endpoint;
    });

    return function findBuildAgent() {
        return _ref.apply(this, arguments);
    };
})();

var _zipBin;

function _load_zipBin() {
    return _zipBin = require("7zip-bin");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _http;

function _load_http() {
    return _http = require("http2");
}

var _child_process;

function _load_child_process() {
    return _child_process = require("child_process");
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _path = _interopRequireWildcard(require("path"));

var _fs;

function _load_fs() {
    return _fs = require("fs");
}

var _nodeHttpExecutor;

function _load_nodeHttpExecutor() {
    return _nodeHttpExecutor = require("builder-util/out/nodeHttpExecutor");
}

var _core;

function _load_core() {
    return _core = require("../core");
}

var _JsonStreamParser;

function _load_JsonStreamParser() {
    return _JsonStreamParser = require("../util/JsonStreamParser");
}

var _timer;

function _load_timer() {
    return _timer = require("../util/timer");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { HTTP2_HEADER_PATH, HTTP2_METHOD_POST, HTTP2_METHOD_GET, HTTP2_HEADER_METHOD, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_STATUS, HTTP_STATUS_OK, HTTP_STATUS_BAD_REQUEST } = (_http || _load_http()).constants;
// noinspection SpellCheckingInspection
const ELECTRON_BUILD_SERVICE_LOCAL_CA_CERT = Buffer.from(`-----BEGIN CERTIFICATE-----
MIIBiDCCAS+gAwIBAgIRAPHSzTRLcN2nElhQdaRP47IwCgYIKoZIzj0EAwIwJDEi
MCAGA1UEAxMZZWxlY3Ryb24uYnVpbGQubG9jYWwgcm9vdDAeFw0xNzExMTMxNzI4
NDFaFw0yNzExMTExNzI4NDFaMCQxIjAgBgNVBAMTGWVsZWN0cm9uLmJ1aWxkLmxv
Y2FsIHJvb3QwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQVyduuCT2acuk2QH06
yal/b6O7eTTpOHk3Ucjc+ZZta2vC2+c1IKcSAwimKbTbK+nRxWWJl9ZYx9RTwbRf
QjD6o0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4E
FgQUlm08vBe4CUNAOTQN5Z1RNTfJjjYwCgYIKoZIzj0EAwIDRwAwRAIgMXlT6YM8
4pQtnhUjijVMz+NlcYafS1CEbNBMaWhP87YCIGXUmu7ON9hRLanXzBNBlrtTQG+i
l/NT6REwZA64/lNy
-----END CERTIFICATE-----
`);
// noinspection SpellCheckingInspection
const ELECTRON_BUILD_SERVICE_CA_CERT = Buffer.from(`-----BEGIN CERTIFICATE-----
MIIBfTCCASOgAwIBAgIRAIdieK1+3C4abgOvQ7pVVqAwCgYIKoZIzj0EAwIwHjEc
MBoGA1UEAxMTZWxlY3Ryb24uYnVpbGQgcm9vdDAeFw0xNzExMTMxNzI4NDFaFw0x
ODExMTMxNzI4NDFaMB4xHDAaBgNVBAMTE2VsZWN0cm9uLmJ1aWxkIHJvb3QwWTAT
BgcqhkjOPQIBBggqhkjOPQMBBwNCAAR+4b6twzizN/z27yvwrCV5kinGUrfo+W7n
L/l28ErscNe1BDSyh/IYrnMWb1rDMSLGhvkgI9Cfex1whNPHR101o0IwQDAOBgNV
HQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU6Dq8kK7tQlrt
zkIYrYiTZGpHEp0wCgYIKoZIzj0EAwIDSAAwRQIgKSfjAQbYlY/S1wMLUi84r8QN
hhMnUwsOmlDan0xPalICIQDLIAXAIyArVtH38a4aizvhH8YeXrxzpJh3U8RolBZF
SA==
-----END CERTIFICATE-----
`);
class RemoteBuilder {
    // noinspection JSMethodCanBeStatic
    build(targets, unpackedDirectory, packager, outDir) {
        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const endpoint = yield findBuildAgent();
            const buildManager = new RemoteBuildManager(endpoint, unpackedDirectory, outDir, packager);
            const result = yield buildManager.build({
                "x-targets": targets,
                "x-platform": packager.platform.buildConfigurationKey
            });
            if (result != null && result.error != null) {
                throw new Error(`Remote builder error (if you think that it is not your application misconfiguration issue, please file issue to https://github.com/electron-userland/electron-builder/issues):\n\n${result.error}`);
            }
        })();
    }
}
exports.RemoteBuilder = RemoteBuilder;

function getZstdCompressionLevel(endpoint) {
    const result = process.env.ELECTRON_BUILD_SERVICE_ZSTD_COMPRESSION;
    if (result != null) {
        return result;
    }
    return endpoint.startsWith("https://127.0.0.1:") || endpoint.startsWith("https://localhost:") || endpoint.startsWith("[::1]:") ? "3" : "19";
}
class RemoteBuildManager {
    constructor(buildServiceEndpoint, unpackedDirectory, outDir, packager) {
        this.buildServiceEndpoint = buildServiceEndpoint;
        this.unpackedDirectory = unpackedDirectory;
        this.outDir = outDir;
        this.packager = packager;
        this.files = null;
        this.finishedStreamCount = 0;
        (0, (_builderUtil || _load_builderUtil()).debug)(`Connect to remote build service: ${buildServiceEndpoint}`);
        const options = {};
        const caCert = process.env.ELECTRON_BUILD_SERVICE_CA_CERT;
        if (caCert !== "false") {
            const isUseLocalCert = (0, (_builderUtil || _load_builderUtil()).isEnvTrue)(process.env.USE_ELECTRON_BUILD_SERVICE_LOCAL_CA);
            if (isUseLocalCert) {
                (0, (_builderUtil || _load_builderUtil()).debug)("Local certificate authority is used");
            }
            options.ca = caCert || (isUseLocalCert ? ELECTRON_BUILD_SERVICE_LOCAL_CA_CERT : ELECTRON_BUILD_SERVICE_CA_CERT);
            // we cannot issue cert per IP because build agent can be started on demand (and for security reasons certificate authority is offline).
            // Since own certificate authority is used, it is ok to skip server name verification.
            options.checkServerIdentity = () => undefined;
        }
        this.client = (0, (_http || _load_http()).connect)(buildServiceEndpoint, options);
    }
    build(customHeaders) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const client = this.client;
            client.on("socketError", reject);
            client.on("error", reject);
            let handled = false;
            client.once("close", () => {
                if (!handled) {
                    reject(new Error("Closed unexpectedly"));
                }
            });
            client.once("timeout", () => {
                reject(new Error("Timeout"));
            });
            this.doBuild(customHeaders, result => {
                handled = true;
                resolve(result);
            }, reject);
        }).catch(error => {
            if (error.code === "ECONNREFUSED") {
                throw new Error(`Cannot connect to electron build service ${this.buildServiceEndpoint}: ${error.message}`);
            } else {
                throw error;
            }
        }).finally(() => {
            this.client.destroy();
        });
    }
    saveConfigurationAndMetadata() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager.info;
            const tempDir = yield packager.tempDirManager.createTempDir({ prefix: "remote-build-metadata" });
            // we cannot use getTempFile because file name must be constant
            const info = {
                metadata: packager.metadata,
                configuration: packager.config,
                repositoryInfo: packager.repositoryInfo
            };
            if (packager.metadata !== packager.devMetadata && packager.devMetadata != null) {
                info.devMetadata = packager.devMetadata;
            }
            const file = _path.join(tempDir, "info.json");
            yield (0, (_fsExtraP || _load_fsExtraP()).outputJson)(file, info);
            return file;
        })();
    }
    doBuild(customHeaders, resolve, reject) {
        this.upload(customHeaders, resolve, reject);
    }
    upload(customHeaders, resolve, reject) {
        const zstdCompressionLevel = getZstdCompressionLevel(this.buildServiceEndpoint);
        const stream = this.client.request(Object.assign({ [HTTP2_HEADER_PATH]: "/v1/upload", [HTTP2_HEADER_METHOD]: HTTP2_METHOD_POST, [HTTP2_HEADER_CONTENT_TYPE]: "application/octet-stream" }, customHeaders, {
            // only for stats purpose, not required for build
            "x-zstd-compression-level": zstdCompressionLevel }));
        stream.on("error", reject);
        // this.handleStreamEvent(resolve, reject)
        this.uploadUnpackedAppArchive(stream, zstdCompressionLevel, reject);
        stream.on("response", headers => {
            const status = headers[HTTP2_HEADER_STATUS];
            if (status !== HTTP_STATUS_OK && status !== HTTP_STATUS_BAD_REQUEST) {
                reject(new Error(`Error: ${status}`));
                return;
            }
            let data = "";
            stream.setEncoding("utf8");
            stream.on("data", chunk => {
                data += chunk;
            });
            stream.on("end", () => {
                const result = data.length === 0 ? {} : JSON.parse(data);
                if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                    (0, (_builderUtil || _load_builderUtil()).debug)(`Remote builder result: ${JSON.stringify(result, null, 2)}`);
                }
                if (status === HTTP_STATUS_BAD_REQUEST) {
                    reject(new Error(JSON.stringify(result, null, 2)));
                    return;
                }
                const id = result.id;
                if (id == null) {
                    reject(new Error("Server didn't return id"));
                    return;
                }
                // cannot connect immediately because channel status is not yet created
                setTimeout(() => this.listenEvents(id, resolve, reject), 3 * 1000 /* min build time */);
            });
        });
    }
    listenEvents(id, resolve, reject) {
        const stream = this.client.request({
            [HTTP2_HEADER_PATH]: `/v1/status/${id}`,
            [HTTP2_HEADER_METHOD]: HTTP2_METHOD_GET
        });
        stream.on("error", reject);
        stream.on("response", headers => {
            if (!checkStatus(headers[HTTP2_HEADER_STATUS], reject)) {
                return;
            }
            stream.setEncoding("utf8");
            const eventSource = new (_JsonStreamParser || _load_JsonStreamParser()).JsonStreamParser(data => {
                if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                    (0, (_builderUtil || _load_builderUtil()).debug)(`Remote builder event: ${JSON.stringify(data)}`);
                }
                if (!("files" in data)) {
                    console.error(`Unknown builder event: ${JSON.stringify(data)}`);
                    return;
                }
                this.files = data.files;
                for (const artifact of this.files) {
                    this.downloadFile(id, artifact, resolve, reject);
                }
            });
            stream.on("data", chunk => eventSource.parseIncoming(chunk));
            stream.on("end", () => {
                console.log("event stream end");
            });
        });
    }
    downloadFile(id, artifact, resolve, reject) {
        const stream = this.client.request({
            [HTTP2_HEADER_PATH]: `/v1/download/${id}/${artifact.file}`,
            [HTTP2_HEADER_METHOD]: HTTP2_METHOD_GET
        });
        stream.on("error", reject);
        const localFile = _path.join(this.outDir, artifact.file);
        const artifactCreatedEvent = this.artifactInfoToArtifactCreatedEvent(artifact, localFile);
        const fileWritten = () => {
            this.finishedStreamCount++;
            if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                (0, (_builderUtil || _load_builderUtil()).debug)(`Remote artifact saved to: ${localFile}`);
            }
            // PublishManager uses outDir and options, real (the same as for local build) values must be used
            this.packager.info.dispatchArtifactCreated(artifactCreatedEvent);
            if (this.files != null && this.finishedStreamCount >= this.files.length) {
                resolve(null);
            }
        };
        stream.on("response", headers => {
            if (!checkStatus(headers[HTTP2_HEADER_STATUS], reject)) {
                return;
            }
            if (artifact.file.endsWith(".yml") || artifact.file.endsWith(".json")) {
                const buffers = [];
                stream.on("end", () => {
                    const fileContent = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers);
                    artifactCreatedEvent.fileContent = fileContent;
                    (0, (_fsExtraP || _load_fsExtraP()).outputFile)(localFile, fileContent).then(fileWritten).catch(reject);
                });
                stream.on("data", chunk => {
                    buffers.push(chunk);
                });
            } else {
                (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(localFile)).then(() => {
                    const fileStream = (0, (_fs || _load_fs()).createWriteStream)(localFile, {
                        // 1MB buffer, download as faster as possible, reduce chance that download will be paused for a while due to slow file write
                        highWaterMark: 1024 * 1024
                    });
                    fileStream.on("error", reject);
                    fileStream.on("close", fileWritten);
                    stream.pipe(fileStream);
                }).catch(reject);
            }
        });
    }
    artifactInfoToArtifactCreatedEvent(artifact, localFile) {
        const target = artifact.target;
        // noinspection SpellCheckingInspection
        return Object.assign({}, artifact, { file: localFile, target: target == null ? null : new FakeTarget(target, this.outDir, this.packager.config[target]), packager: this.packager });
    }
    // compress and upload in the same time, directly to remote without intermediate local file
    uploadUnpackedAppArchive(stream, zstdCompressionLevel, reject) {
        this.saveConfigurationAndMetadata().then(infoFile => {
            const compressAndUploadTimer = (0, (_timer || _load_timer()).time)("compress and upload");
            // noinspection SpellCheckingInspection
            const tarProcess = (0, (_child_process || _load_child_process()).spawn)((_zipBin || _load_zipBin()).path7za, ["a", "dummy", "-ttar", "-so", this.unpackedDirectory, infoFile], {
                stdio: ["pipe", "pipe", process.stderr]
            });
            tarProcess.stdout.on("error", reject);
            const zstdProcess = (0, (_child_process || _load_child_process()).spawn)("zstd", [`-${zstdCompressionLevel}`, "--long"], {
                stdio: ["pipe", "pipe", process.stderr]
            });
            zstdProcess.on("error", reject);
            tarProcess.stdout.pipe(zstdProcess.stdin);
            zstdProcess.stdout.pipe(stream);
            zstdProcess.stdout.on("end", () => {
                compressAndUploadTimer.end();
            });
        }).catch(reject);
    }
}
function checkStatus(status, reject) {
    if (status === HTTP_STATUS_OK) {
        return true;
    }
    if (status === (_http || _load_http()).constants.HTTP_STATUS_SERVICE_UNAVAILABLE) {
        reject(new Error(`Error: request rate limit exceeded, please retry after 15 seconds`));
        return false;
    } else {
        reject(new Error(`Error: ${status}`));
        return false;
    }
}
class FakeTarget extends (_core || _load_core()).Target {
    constructor(name, outDir, options) {
        super(name);
        this.outDir = outDir;
        this.options = options;
    }
    build(appOutDir, arch) {
        // no build

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {})();
    }
}
//# sourceMappingURL=RemoteBuilder.js.map